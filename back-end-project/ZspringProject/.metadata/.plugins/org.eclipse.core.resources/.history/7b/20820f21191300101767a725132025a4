package StreamApi_InterviewQuestions;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

public class HighestSalary {

	public static void main(String[] args) {
		List<Employee> empList = new ArrayList<>();

		empList.add(new Employee("Abdul", 23, 45000.0, "SE"));
		empList.add(new Employee("Morris", 23, 13000.0, "Developer"));
		empList.add(new Employee("Rahil", 23, 435000.0, "Manager"));
		empList.add(new Employee("John", 23, 415000.0, "CEO"));
		empList.add(new Employee("Adam", 23, 500000.0, "SrEng"));
		empList.add(new Employee("Marriq", 23, 3782323.0, "Head"));
		empList.add(new Employee("Pane", 23, 28878.0, "Founder"));

		/* highest salary */
//		Employee highest = empList.stream().sorted(Comparator.comparingDouble(Employee::getSal).reversed())
//				.findFirst().get();
//		System.out.print(highest);

		/* second highest salary */

//		Employee secondHighest = empList.stream().sorted(Comparator.comparingDouble(Employee::getSal).reversed()).skip(1)
//				.findFirst().get();
//		System.out.print(secondHighest);

		/* third highest salary */
		
//		Employee thirdHighest = empList.stream().sorted(Comparator.comparingDouble(Employee::getSal).reversed()).skip(2)
//				.findFirst().get();
//		System.out.print(thirdHighest);
		
		
		/* third highest salary */
		
//		Double collect = empList.stream().collect(Collectors.averagingDouble(Employee::getSal));
//		System.out.println(collect);
		
		/* sort the list of employee  by name */
		
//		List<Employee> listOfEmp = empList.stream().sorted(Comparator.comparing(Employee::getName)).collect(Collectors.toList());
//		listOfEmp.forEach(n->System.out.println(n));
		List<Employee> lst=empList.stream().sorted(Comparator.comparingDouble(Employee::getSal)).collect(Collectors.toList());
		lst.forEach(x->System.out.println(lst));
		
		
//		*****************************NOTE for "::" *********************************
		
//		In Java 8 and later, :: is the method reference operator, used to refer to a method without executing it, allowing for concise lambda expressions. 
//		Here's a breakdown:
//		What it does:
//		It's a shorthand way to express a lambda expression when the lambda's body is simply a call to an existing method. 
//		How it works:
//		It allows you to directly reference a method (either static or instance) by its name, rather than writing out the entire lambda expression. 
//		Examples:
//		Static method reference: ClassName::methodName (e.g., String::toUpperCase) 
//		Instance method reference: object::methodName (e.g., myObject::myMethod) 
//		Instance method reference (arbitrary object): ClassName::methodName (e.g., String::equals) 
//		Benefits:
//		Makes code more readable and compact, especially when using functional interfaces with streams and other lambda-based feature
	}

}
